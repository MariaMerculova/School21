### Существует четыре общих уровня веб-приложений:

Уровень представления (PL)  
Уровень обслуживания данных (DSL)  
Уровень бизнес-логики (BLL)  
Уровень доступа к данным (DAL)  

#### Уровень представления (PL)
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.

#### Уровень обслуживания данных (DSL)
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.

#### Слой бизнес-логики (BLL)
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.

#### Уровень доступа к данным (DAL)
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.

**Монолитная архитектура** — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Монолитом часто называют нечто большое и неповоротливое, и эти два слова хорошо описывают монолитную архитектуру для проектирования ПО. Монолитная архитектура — это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.

**Микросервисная архитектура** (или просто «микросервисы») представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. Микросервисы не снижают сложность, но они делают любую сложность видимой и более управляемой, разделяя задачи на более мелкие процессы, которые функционируют независимо друг от друга и вносят вклад в общее целое.

##### Различия между монолитом и микросервисами

**Микросервисы** – вариант сервис-ориентированной архитектуры ПО, который обеспечивает взаимодействие независимых друг от друга небольших, слабо связанных и легко изменяемых модулей. 

**Монолитная архитектура** представляет собой единый модуль, работающий автономно, независимо от других приложений.

Монолитная архитектура подходит для небольших и средних проектов со стабильным объемом функционала, тогда как микросервисная архитектура подходит для больших и сложных проектов, которые могут вырасти в будущем и требуют расширения и масштабирования.


##### Почему  не все приложения построены на микросервисной архитектуре

Не всегда крупные холдинги выбирают микросервисную архитектуру. Все зависит от целей приложения, так как они имеют и ряд недостатков. Например, на начальном этапе их сложнее разрабатывать: необходимо создать некий фундамент, или ядро приложения.

На микросервисах это занимает больше времени в сравнении с монолитом: нужно продумать архитектуру будущих сервисов и решить вопросы взаимодействия их между собой – то, как они будут обмениваться информацией. Ведь каждый отдельный сервис не знает о том, что делают другие, и имеет в распоряжении очень ограниченный набор данных.

На монолите такие задачи в принципе не приходится решать, а потому микросервисная архитектура потребует более высокой квалификации как архитектора проекта, так и разработчиков.

Также поддержка решения на микросервисах может потребовать более высокой компетенции инженеров, отвечающих за эксплуатацию приложения, поиск и анализ ошибок в его работе. Это будет сложнее ввиду распределенности функций на разные кусочки системы.

Еще одна причина, по которой бизнес массово не переходит на микросервисы,- не предполагается высокой нагрузки и регулярных доработок программы.

##### Итог

Все зависит от  организационной структуры. У вас есть 6 команд, которые будут работать над одним продуктом? Микросервисы могут подойти.

У вас есть команда из 3 разработчиков? Вероятно, они будут хорошо строить и поддерживать монолит.
